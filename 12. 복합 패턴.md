복합 패턴 : 여러 패턴을 함께 사용해서 다양한 디자인 문제를 해결하는 방법

예제 - 오리 시뮬레이션 게임에 다양한 패턴 적용하기

여러 Quackable 오리 클래스

```java
public interface Quackable {
    public void quack();
}

public class MallardDuck implements Quackable {
    public bond quack() {
        System.out.println(“꽥꽥”);
    }
}

public class RedheadDuck implements Quackable {
    public bond quack() {
        System.out.println(“꽥꽥”);
    }
}

public class Duckcall implements Quackable {
    public bond quack() {
        System.out.println(“꽉꽉”);
    }
}

public class RubberDuck implements Quackable {
    public bond quack() {
        System.out.println(“삑삑”);
    }
}
```

거위도 Quackable에 포함 -> 어댑터 패턴
```java
public class Goose {
    public void honk() {
        System.out.println(“끽끽”);
    }
}

public class GooseAdapter implements Quackable {
    Goose goose;

    public GooseAdapter(Goose goose) {
        this.goose = goose;
    }

    public void quack() {
        goose.hook();
    }
}
```

꽥꽥 소리가 난 횟수 세기 -> 데코레이터 패턴
```java
public class Quackcounter implements Quackable {
    Quackable duck;
    static int numberOfQuacks;
    
    public QuackCounter (Quackable duck) {
        this.duck = duck;
    }

    public void quack() {
        duck.quack();
        numberOfQuacks++;
    }

    public static int getQuacks() {
        return numberOfQuacks;
    }
}

public class DuckSimulator() {
    …

    void simulate() {
        Quackable  mallardDuck = new QuackCounter(new MallarDuck());
        Quackable  redheadDuck = new QuackCounter(new RedheadDuck());
        Quackable  duckCall = new QuackCounter(new DuckCall());
        Quackable  rubberDuck = new QuackCounter(new RubberDuck());
        Quackable  gooseDuck = new QuackCounter(new Goose());
    
        …
    } 
}
```


데코레이터로 감싸는 부분 캡슐화 -> 추상 팩토리 패턴
```java
public abstract class AbstractDuckFactory {
    public abstract Quackable createMallardDuck();
    public abstract Quackable createRedheadDuck();
    public abstract Quackable createDuckCall();
    public abstract Quackable createRubberDuck();
}

public class DuckFactory extends AbstractDuckFactory() {
    public Quackable createMallardDuck() {
        return new MallardDuck();
    }

    …
}

public class CountingDuckFactory extends AbstractDuckFactory {
    public Quackable createMallardDuck() {
        return new QuackCounter(new MallarDuck()); 
    }
    …
}

public class DuckSimulator() {
    …

    void simulate(AbstractDuckFactory duckFactory) {
        Quackable  mallardDuck = duckFacyory.createMallarDuck();
        Quackable  redheadDuck = duckFacyory.createRedheadDuck();
        Quackable  duckCall = duckFacyory.createDuckCall();
        Quackable  rubberDuck = duckFacyory.createRubberDuck();
        Quackable  gooseDuck = new QuackCounter(new Goose());
    
        …
    } 
}
```


Quackable 객체를 관리하기 힘들어짐 -> 컴포지트 패턴
```java
public class Flock implements Quackable {
    List<Quackable> quackery = new ArrayList<Quackable>();
    public void add(Quackable quacker) {
        quackery.add(quacker);
    }

    public void quack() {
        Iterator<Quackable> iterator = quackers.iterator();
        While (iterator.hasNext()) {
            Quackable quacker = iterator.next();
            quacker.quack(); 
        }
    }
}

public class DuckSimulator() {
    …

    void simulate(AbstractDuckFactory duckFactory) {
        Quackable  mallardDuck = duckFacyory.createMallarDuck();
        Quackable  redheadDuck = duckFacyory.createRedheadDuck();
        Quackable  duckCall = duckFacyory.createDuckCall();
        Quackable  rubberDuck = duckFacyory.createRubberDuck();
        Quackable  gooseDuck = new QuackCounter(new Goose());
    
        Flock flockOfDucks = new Flock();
        
        flockOfDucks.add(redheadDUck);
        flockOfDucks.add(duckCall);
        flockOfDucks.add(rubberDuck);
        flockOfDucks.add(gooseDuck);
    } 
}
```


Quackable에서 소리를 냈을때 알고 싶음 -> 옵저버 패턴
```java
public interface quackObservable {
    public void registerObserver(Observer observer);
    public void notifyObservers();
}

public interface Quackable extents QuackObservable {
    public void quack();
}

public class Observable implements QuackObservable {
    List<Observer> observers = new ArrayLisy<Observer>();
    QuackObservable duck;

    public Observable(QuackObservable duck) {
        this.duck = duck;
    }

    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    public void notifyObservers() {
        Iterator iterator = observers.iterator();
        while (iterator.hasNext()) {
            Observer observer = iterator.next();
            observer.update(duck);
        }
    }
}

public class MallarDuck implements Quackable {
    Observable observable;

    public MallarDuck() {
        observable = new Observable(this); 
    }

    public void quack() {
        System.out.println(“꽥꽥”);
        notifyObservers();
    }

    public void registerObserver(Observer observer) {
        observable.registerObserver(observer);
    }

    public void notifyObservers() {
        observable.notifyObservers();
    }
}

public interface Observer {
    public void update(QuackObservable duck);
} 

public class Quackologist implements Observer {
    public void update(QuackObservable duck) {
        System.out.println(“꽥꽥학자: ” + duck + “ 가 방금 소리냈다.”)
    }
}

public class DuckSimulator() {
    …

    void simulate(AbstractDuckFactory duckFactory) {
        // 오리 팩토리와 오리 생성
        // 오리 무리 생성

        Quakologist quackologist = new Quackologist();
        flockOfDucks.registerObserver(quackologist);
    } 
}
```

지금까지 쓰인것들이 복합패턴인가요?  No!



복합 패턴의 왕 MVC 알현
- MVC song
컨트롤러 : “텍스트 필드에 문자열을 보낼 때마다 100원씩만 받아도 좋겠어”


모델
모델에는 모든 데이터, 상태와 애플리케이션 로직이 들어있습니다.
뷰와 컨트롤러에서 모델의 상태를 조작하거나 가져올 때 필요한 인터페이스를 제공합니다.
모델이 자신의 상태 변화를 옵저버들에게 연락해 주긴 하지만, 기본적으로 모델은 뷰와 컨트롤러에게 관심이 없습니다.

뷰
모델을 표현하는 방법을 제공합니다.
일반적으로 화면에 표시할 때 필요한 상태와 데이터는 모델에서 직접 가져옵니다. (풀 방식)

컨트롤러
사용자로부터 입력을 받으며 입력받은 내용이 모델에게 어떤 의미가 있는지 파악합니다.



사용자는 뷰에만 접근할수 있습니다.
컨트롤러가 모델에게 상태를 변경하라고 요청합니다.
컨트롤러가 뷰를 변경해 달라고 요청할수 있습니다.
상태가 변경되면 모델이 뷰에게 그 사실을 알립니다.
뷰가 모델에게 상태를 요청합니다.


뷰에 컨트롤러 역할을 넣어도 되지 않나요?
뷰가 2가지 역할을 하게되면 뷰 코드가 복잡해 질수 있다. (사용자 인터페이스 관리 + 모델 제어)
뷰와 모델이 너무 밀접하게 결합될 수 있다.


MVC 패턴은 여러 개의 패턴이 함께 적용되어서 완성된 하나의 패턴.
컨트롤러 - 전략 패턴
뷰 - 전략 패턴, 컴포지트 패턴
모델 - 옵저버 패턴



예제 - MVC로 BOM 제어 도구 만들기

모델 (인터페이스)
```java
public interface BeatModelInterface {
    void initialize();
    void on();
    void off();
    void setBPM(int bpm);

    int getBPM();
    void registerObserver(BeatObserver o); 
    void removeObserver(BeatObserver o);
    void registerObserver(BPMObserver o); 
    void removeObserver(BPMObserver o);
} 
```


뷰

// 비트 막대를 표시하는 모델용 뷰
```java
public class DJView implements ActionListener, BeatObserver, BPMObserver {
    …
    
    public DJView(ControllerInterface controller, BeatModelInterface model) {}
    public void create() {}
    public void updateBPM() {}
    public void updateBeat() {}
}

// 사용자 인터페이스 제어 부분
public class DJView implements ActionListener, BeatObserver, BPMObserver {
    …
    
    public void crateControls() {}
    public void enableStopMenuItem() {}
    public void disableStopMenuItem() {}
    public void enableStartMenuItem() {}
    public void disableStartMenuItem() {}
    public void actionPerformed(ActionEvent event) {}
}
```


컨트롤러
```java
public interface ContollerInterface {
    void start();
    void stop();
    void increaseBPM();
    void decreaseBPM();
    void setBPM(int bpm);
}

실행
public class DJTestDrice {
    public static void main (String[] args) {
        BeatModelInterface model = new BeatModel();
        ControllerInterface controller = new BeatController(model);
    }
}
```


